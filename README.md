# Day 1
Inception of open source EDA
![1](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/1.PNG?raw=true)
Board Diagram
Signals are tranmistted from inside of chip to outside using pads

Foundry - Place where Chips get manufactured

Macros - Pure DIgital Logic

IP - Intellectual Property -requires intelligence to build
 ## Introduction to ISA

Language with which we talk to computers
Passing on the info to hardware
C program - Assembly level Program - Machine Level Program (binary)
![2](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/2.PNG?raw=true)

## From Software Apps to hardware
Apps - System Software - Binary Language
![3](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/3.PNG?raw=true)
The Compiler converts the respecticve intruction in which the hardware has been designed (RISC-V or ARM or x86)
![4](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/4.PNG?raw=true)
## From Software Application to hardware
ASIC requires

THe RTL code & PDK & EDA Tools

### Process Design kits

Collection of files used to model a fab process in designing an IC

Steps are:

Synthesis - Floor and Power Planning - Placement - Clock Tree Synthesis - Routing - Signoff

![5](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/5.PNG?raw=true)
### Introduction to OPENLANE
![6](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/6.PNG?raw=true)
Strive soc
Goal - Generate Clean GDS2 with no human Intervention
![7](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/7.PNG?raw=true)
Open Lane ASIC FLow
![8](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/8.PNG?raw=true)
Design Prep Step

Package Importing
![9](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/9.PNG?raw=true)
Design present in openlane and hierrachy in design
![10](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/10.PNG?raw=true)
![11](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/11.PNG?raw=true)
prepare design for FLow
![12](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/12.PNG?raw=true)
![13](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/13.PNG?raw=true)
Synthesis
Finding ratio of no of D flipflop to total number of cells
![14](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/14.PNG?raw=true)
##Lab
Run the command run_flooorplan in the openlane shell

Go to the /Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/(date)/results/floorplan directory and run the following command:

magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &

![15](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/15.PNG?raw=true)
![16](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/16.PNG?raw=true)
zoomed in

Placement and Routing
![17](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/17.PNG?raw=true)

To view the placement, type run_placement in the openlane shell.

We type the following command in the terminal in the ../OpenLane/designs/picorv32a/runs/<most_recent_run>/results/placement/ directory

magic -T ../git_open_pdks/sky130/magic/sky130.tech lef read ../OpenLane/designs/picorv32a/runs/<most_recent_run>/tmp/merged.nom.lef def read picorv32.def &

![18](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/18.PNG?raw=true)

run_placement

Talking to computers involves understanding the various layers of interaction in a digital system, from high-level programming languages down to the physical hardware. Here, we'll explore the process of executing a C program on a specific hardware platform, particularly focusing on the RISC-V architecture as an example.

1. **High-Level Programming:** Application software, such as C, C++, or Python programs, is typically written in high-level languages that are human-readable and user-friendly. These programs perform various tasks, from simple calculations to complex algorithms.

2. **Compilation:** High-level code is compiled using a compiler, which translates the code into assembly instructions specific to the target processor architecture. The compiler ensures that the high-level code is converted into a format that the hardware can understand.

3. **Assembler:** The assembly code generated by the compiler is further translated into binary machine code by an assembler. This binary code represents the instructions and data needed to execute the program on a particular processor.

4. **Hardware Implementation:** At the hardware level, the digital system consists of components like processors, memory, input/output interfaces, and more. The processor interprets and executes the binary instructions.

5. **RTL (Register Transfer Level) Implementation:** An RTL description of the hardware is created to map the binary instructions to specific hardware components and data paths. This is crucial for designing and optimizing the hardware layout.

6. **Layout Design:** The RTL description is used to create the physical layout of the hardware, including the placement of logic gates, flip-flops, wires, and other components on the silicon die.

7. **EDA Tools (Electronic Design Automation):** Various EDA tools are used throughout the design process. These tools help with synthesis (translating RTL to gates), floor planning (designing the chip layout), placement (positioning components), routing (connecting components), and more.

8. **Integration:** The synthesized design, which includes logic gates, is integrated into a larger system, which may include multiple cores, peripherals, and memory.

9. **Testing and Verification:** Extensive testing is performed to ensure that the hardware behaves as expected and meets the design specifications. This includes simulation, functional testing, and timing analysis.

10. **Fabrication:** Once the design is finalized, it's sent for fabrication, where the physical chip is manufactured based on the layout.

11. **Execution:** When the hardware is ready, it can execute the binary instructions generated from the original high-level program.

The process described here highlights the layers of abstraction and transformation required to go from a high-level program to actual hardware execution. Understanding this process is crucial for computer engineers and software developers who want to work at various levels of the technology stack, from software development to hardware design and integration.

In a chip floor planning process, several key considerations and steps are taken into account to ensure efficient chip design and utilization. Here, we outline the important aspects of this process.

**Utilization Factor and Aspect Ratio:**
- Utilization Factor = Area Occupied by Netlist / Total Area of the Core
- Aspect Ratio = Height / Width
- Consider practical utilization factors and aspect ratios.

**Pre-Placed Cells:**
- Split the design into blocks, extend I/O pins, and create reusable blocks.
- Pre-placed cells are user-defined blocks placed before automated placement and routing.
- Allows for efficient design reuse.

**Decoupling Capacitors:**
- Decoupling capacitors help manage power supply fluctuations.
- Placed in parallel with the circuit to provide instantaneous current during switching.
- Ensures stable operation.

**Pin Placement:**
- Use HDL netlist to determine the location of specific pins.
- Optimize connections for efficiency.
- Place pins in the chip's die area.

**Running Floorplan in OpenLANE:**
- Execute "run_floorplan" in the OpenLANE shell.
- Use "magic" to visualize the floorplan layout.

**Library Binding and Placement:**
- Cells in a library have dimensions and must be placed carefully.
- Libraries consist of various cells with different characteristics.
- Components of the netlist are placed in the core area for efficient connectivity.

**Viewing Placement:**
- Run "run_placement" in OpenLANE.
- Visualize placement using "magic."

**Cell Design and Characterization Flow:**
- Cell design involves circuit and layout design, characterization, and outputs like CDL, GDSII, LEF, and extracted spice netlists.
- Characterization flow includes reading model files, applying stimuli, and determining timing parameters like propogation delay and transition time.

**Timing Characterization Parameters:**
- Propogation delay: time(out_fall_thr) - time(in_rise_thr)
- Transition time (On rise/fall): time(slew_high) - time(slew_low)

This comprehensive approach ensures efficient chip design, reuse of pre-placed cells, and accurate timing characterization.

##Day 3
Modifying to 2
![19](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/19.PNG?raw=true)
After making modifications to the floorplan, we obtain a configuration of input/output (I/O) pins that are vertically aligned or superimposed on each other.
![20](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/20.PNG?raw=true)
![21](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/21.PNG?raw=true)
Git cloning
![23](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/23.PNG?raw=true)
after running following command we get this output
![22](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/22.PNG?raw=true)
### Inception of layout A in CMOS Fab process
In the image above, we observe the layout design of an inverter circuit in the software tool Magic. This layout design includes both PMOS and NMOS transistors with their respective source and drain connections. The distinctive colors, such as red, blue, and green, are standard indications for various materials like polysilicon and metal layers. Each color corresponds to a specific metal layer, crucial for defining the interconnections within the circuit. The layout design meticulously adheres to specific design rules, a fundamental aspect in creating integrated circuits. It visually represents the intricate connections between the PMOS and NMOS transistors and how their source and drain terminals are interconnected. Additionally, it highlights the careful adherence to layer specifications and design guidelines necessary for the successful creation of the circuit layout.


![24](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/24.PNG?raw=true)
COmmands to extract spice netlist

![25](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/25.PNG?raw=true)
Output of spice file

![26](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/26.PNG?raw=true)
modifying the spice file
![27](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/27.PNG?raw=true)
Running ngspice tool
![28](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/28.PNG?raw=true)

Waveform
Results : 
   Rise Transition : 0.0395ns
   Fall transition : 0.0282ns
   Cell Rise delay : 0.03598ns
   Cell fall delay : 0.0483ns

# Prelayout Timing Analysis

Track info
![29](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/29.PNG?raw=true)


![30](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/30.PNG?raw=true)
After setting GRID

mag file output opened using Magic
![31](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/31.PNG?raw=true)
After running these COmmands
package require openlane 0.9
prep -design picorv32a -tag unique_timestamp -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis
![32](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/32.PNG?raw=true)
![33](https://github.com/Akshay1000101/pes_pd/blob/main/screen_shots/33.PNG?raw=true)

In the process of designing and synthesizing a custom cell in OpenLANE, several critical steps are involved, ensuring the successful integration of the custom cell into the digital design flow.

1. **Timing Modelling Using Delay Tables:** The design begins with the creation of delay tables to model the cell's timing behavior. These tables capture how signal delays vary with different inputs and are crucial for accurate timing analysis.

2. **Convert Grid Info to Track Info:** The grid information is converted into track information, which is essential for routing and ensuring that metal traces align with the grid.

3. **Routing Configuration:** The 'tracks.info' file, vital for routing, is examined to specify the routing paths for metal traces. It defines the routes for metal traces, which represent interconnections.

4. **Layout to Track Definition:** The grid definition in the layout is converted into track definitions, aligning the routing grid with the design. This step ensures that routing occurs precisely along the specified tracks.

5. **Width Alignment:** The cell's width should be an odd multiple of the x-pitch, as defined in the 'tracks.info' file. This ensures that the cell's dimensions align correctly with the routing grid.

6. **Convert Magic Layout to Standard Cell LEF:** The custom cell layout created in Magic is converted into a standard cell Library Exchange Format (LEF) file. This file format is essential for compatibility with the digital design flow.

7. **Include New Cell in Synthesis:** The custom cell, in the form of a '.mag' file, is copied to the 'src' folder of the target design. The 'config.tcl' file in the design folder is modified to include the new cell in the synthesis process.

8. **Preparation and Synthesis:** The OpenLANE interactive window is used to prepare the design, including adding the new cell's LEF file and running synthesis.

9. **Floorplan and Placement:** The floorplan and placement stages are executed to determine the placement of cells on the chip.

10. **Design Visualization:** The design can be viewed using Magic, providing insight into the placement of cells and ensuring that the custom cell has been successfully integrated.

11. **Timing Analysis with Ideal Clocks:** The setup for timing analysis using ideal clocks involves configuring files such as 'pre_sta.conf' and 'my_base.sdc.' Timing analysis is executed using the 'sta' command, and any slack violations are addressed.

12. **Clock Tree Synthesis (CTS):** CTS is performed to optimize the clock distribution network, ensuring that clock signals are efficiently delivered to all parts of the design.

13. **Timing Analysis with Real Clocks:** Timing analysis is run again, this time considering real clock signals. OpenROAD is used to read various design and library files, and timing checks are performed to ensure that the design meets the specified timing constraints.

14. **Signal Skew Analysis:** Additional checks are performed to analyze clock skew and identify any potential issues related to clock distribution and timing.

These steps collectively ensure that the custom cell is successfully integrated into the digital design flow, and the design meets the required timing constraints and performance criteria.

# DAY 5
Once the clock tree network has been generated and the post-routing Static Timing Analysis (STA) checks have been successfully verified in OpenLANE, the next step is to create the power distribution network (PDN). This PDN feature within OpenLANE serves several essential functions:

1. **Power Ring**: It establishes a global power ring that encircles the entire core of the chip, ensuring a uniform distribution of power throughout the design.

2. **Power Halo**: Locally, it caters to any preplaced cells by creating a power halo, ensuring efficient power delivery to these specific areas.

3. **Power Straps**: To bring power into the center of the chip, power straps are employed, enhancing the reliability and integrity of power distribution.

4. **Power Rails**: Power rails are generated for the standard cells, and the pitch of the metal 1 power rails defines the height of these standard cells, ensuring proper alignment and connectivity.

The routing phase in OpenLANE consists of two critical stages:

1. **Global Routing**: During this stage, routing guides are generated based on the netlist, specifying which layers and locations on the chip each net should be routed. It sets the initial framework for interconnections.

2. **Detailed Routing**: In the subsequent step, metal traces are iteratively laid across the routing guides to physically implement the interconnections, completing the routing process.

If any Design Rule Check (DRC) errors persist even after routing, the user has two options:

1. **Re-run Routing with Higher QoR Settings**: Rerouting can be attempted with higher Quality of Results (QoR) settings to potentially resolve the DRC errors automatically.

2. **Manual DRC Error Fixing**: Alternatively, specific DRC errors can be manually addressed based on the information provided in the tritonRoute.drc file.

After routing has been successfully completed, the next step is to extract interconnect parasitics for sign-off post-route STA analysis. These parasitics are extracted into a Standard Parasitic Exchange Format (SPEF) file. It's worth noting that the SPEF extractor is not included within OpenLANE, so a separate tool or script must be used. The process involves navigating to the SPEFEXTRACTOR directory, executing the Python script (main.py) with the paths to the merged LEF file (tmp) and the DEF file generated during routing. The resulting SPEF file will be located in the same directory as the DEF file, containing the essential parasitic information required for post-route STA analysis.